
<!DOCTYPE html>
<html>    <head>        <meta name="viewport" content="width=device-width,initial-scale=1">
        <meta http-equiv="content-type" content="text/html; charset=utf-8">
        <link rel="stylesheet" type="text/css" href="css/proj_docs.css">
        <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
        <script type="text/javascript" src="js/sidebar.js"></script>
        <script type="text/javascript" src="js/listanchors.js"></script>
        <title>libc</title>
        
        
    </head>
    <body>        
        <div class="container">            
<div class="sidebar-underbar"></div>
<div class="sidebar">    <div class="head">        <h2>d_tree_sitter</h2>
        <p><span class="smallprint"><b>version:</b> 1.2.0 <span class="separator"><br></span>
            </span>
        </p>
        <p><a href="index.html">overview</a></p>
    </div>
    
    <ul>

	
	
	
		<li class="expand-container open"><a class='expand-toggle' href="#"><span >d_tree_sitter</span></a><ul>
			
	
	
		<li class="expand-container open"><a class='expand-toggle' href="#"><span >core</span></a><ul>
			
	
	
		<li class="expand-container open"><a class='expand-toggle' href="#"><span >stdc</span></a><ul>
			

	<li><a title="D header file for C99." href="d_tree_sitter--d_tree_sitter.core.stdc.stdbool.html"><span >stdbool</span></a></li>


		</ul></li>
	




		</ul></li>
	





	<li><a title="" href="d_tree_sitter--d_tree_sitter.language.html"><span >language</span></a></li>



	<li><a title="" href="d_tree_sitter--d_tree_sitter.libc.html"><span >libc</span></a></li>



	<li><a title="" href="d_tree_sitter--d_tree_sitter.node.html"><span >node</span></a></li>



	<li><a title="" href="d_tree_sitter--d_tree_sitter.other.html"><span >other</span></a></li>



	<li><a title="" href="d_tree_sitter--d_tree_sitter.parser.html"><span >parser</span></a></li>



	<li><a title="" href="d_tree_sitter--d_tree_sitter.query.html"><span >query</span></a></li>



	<li><a title="" href="d_tree_sitter--d_tree_sitter.tree.html"><span >tree</span></a></li>



	<li><a title="" href="d_tree_sitter--d_tree_sitter.tree_cursor.html"><span >tree_cursor</span></a></li>



	<li><a title="" href="d_tree_sitter--d_tree_sitter.tree_printer.html"><span >tree_printer</span></a></li>



	<li><a title="" href="d_tree_sitter--d_tree_sitter.tree_visitor.html"><span >tree_visitor</span></a></li>


		</ul></li>
	




</ul>
</div>
            <div class="content">                <h1>libc</h1>
                
                <div class="quickindex" id="quickindex"></div>
                
                
<dl class="ddoc_members"><div class="ddoc_module_members"><dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_set_allocator"></span><div class="quickindex" id="quickindex.ts_set_allocator"></div>nothrow @nogc void <code class="ddoc_psymbol">ts_set_allocator</code>(void* function(ulong), void* function(ulong, ulong), void* function(void*, ulong), void function(void*));
<br></div></dt>
<dd><div class="ddoc_summary">Set the allocation functions used by the library.
</div><div class="ddoc_description">By default, Tree-sitter uses the standard libc allocation functions,
 but aborts the process when an allocation fails. This function lets
 you supply alternative allocation functions at runtime.
<div class="ddoc_blankline"></div>

 If you pass <code class="d_inlinecode donthyphenate notranslate">NULL</code> for any parameter, Tree-sitter will switch back to
 its default implementation of that function.
<div class="ddoc_blankline"></div>

 If you call this function after the library has already been used, then
 you must ensure that either:
<ol><li>All the existing objects have been freed.</li>
<li>The new allocator shares its state with the old one, so it is capable
     of freeing memory that was allocated by the old allocator.</li>
</ol></div>
</dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_language_version"></span><div class="quickindex" id="quickindex.ts_language_version"></div>nothrow @nogc uint <code class="ddoc_psymbol">ts_language_version</code>(const(TSLanguage)*);
<br></div></dt>
<dd><div class="ddoc_summary">Get the ABI version number for this language. This version number is used
 to ensure that languages were generated by a compatible version of
 Tree-sitter.
</div><div class="ddoc_description">See also <code class="d_inlinecode donthyphenate notranslate">ts_parser_set_language</code>.</div>
</dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_language_symbol_type"></span><div class="quickindex" id="quickindex.ts_language_symbol_type"></div>nothrow @nogc TSSymbolType <code class="ddoc_psymbol">ts_language_symbol_type</code>(const(TSLanguage)*, ushort);
<br></div></dt>
<dd><div class="ddoc_summary">Check whether the given node type id belongs to named nodes, anonymous nodes,
 or a hidden nodes.
</div><div class="ddoc_description">See also <code class="d_inlinecode donthyphenate notranslate">ts_node_is_named</code>. Hidden nodes are never returned from the API.</div>
</dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_language_field_id_for_name"></span><div class="quickindex" id="quickindex.ts_language_field_id_for_name"></div>nothrow @nogc ushort <code class="ddoc_psymbol">ts_language_field_id_for_name</code>(const(TSLanguage)*, const(char)*, uint);
<br></div></dt>
<dd><div class="ddoc_summary">Get the numerical id for the given field name string.</div></dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_language_field_name_for_id"></span><div class="quickindex" id="quickindex.ts_language_field_name_for_id"></div>nothrow @nogc const(char)* <code class="ddoc_psymbol">ts_language_field_name_for_id</code>(const(TSLanguage)*, ushort);
<br></div></dt>
<dd><div class="ddoc_summary">Get the field name string for the given numerical id.</div></dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_language_field_count"></span><div class="quickindex" id="quickindex.ts_language_field_count"></div>nothrow @nogc uint <code class="ddoc_psymbol">ts_language_field_count</code>(const(TSLanguage)*);
<br></div></dt>
<dd><div class="ddoc_summary">Get the number of distinct field names in the language.</div></dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_language_symbol_for_name"></span><div class="quickindex" id="quickindex.ts_language_symbol_for_name"></div>nothrow @nogc ushort <code class="ddoc_psymbol">ts_language_symbol_for_name</code>(const(TSLanguage)*, const(char)*, uint, bool);
<br></div></dt>
<dd><div class="ddoc_summary">Get the numerical id for the given node type string.</div></dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_language_symbol_name"></span><div class="quickindex" id="quickindex.ts_language_symbol_name"></div>nothrow @nogc const(char)* <code class="ddoc_psymbol">ts_language_symbol_name</code>(const(TSLanguage)*, ushort);
<br></div></dt>
<dd><div class="ddoc_summary">Get a node type string for the given numerical id.</div></dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_language_symbol_count"></span><div class="quickindex" id="quickindex.ts_language_symbol_count"></div>nothrow @nogc uint <code class="ddoc_psymbol">ts_language_symbol_count</code>(const(TSLanguage)*);
<br></div></dt>
<dd><div class="ddoc_summary">Get the number of distinct node types in the language.</div></dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_query_cursor_next_capture"></span><div class="quickindex" id="quickindex.ts_query_cursor_next_capture"></div>nothrow @nogc bool <code class="ddoc_psymbol">ts_query_cursor_next_capture</code>(TSQueryCursor*, TSQueryMatch*, uint*);
<br></div></dt>
<dd><div class="ddoc_summary">Advance to the next capture of the currently running query.
</div><div class="ddoc_description">If there is a capture, write its match to <code class="d_inlinecode donthyphenate notranslate">*match</code> and its index within
 the matche's capture list to <code class="d_inlinecode donthyphenate notranslate">*capture_index</code>. Otherwise, return <code class="d_inlinecode donthyphenate notranslate">false</code>.</div>
</dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_query_cursor_next_match"></span><div class="quickindex" id="quickindex.ts_query_cursor_next_match"></div>nothrow @nogc bool <code class="ddoc_psymbol">ts_query_cursor_next_match</code>(TSQueryCursor*, TSQueryMatch*);
<br></div></dt>
<dd><div class="ddoc_summary">Advance to the next match of the currently running query.
</div><div class="ddoc_description">If there is a match, write it to <code class="d_inlinecode donthyphenate notranslate">*match</code> and return <code class="d_inlinecode donthyphenate notranslate">true</code>.
 Otherwise, return <code class="d_inlinecode donthyphenate notranslate">false</code>.</div>
</dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_query_cursor_set_byte_range"></span><div class="quickindex" id="quickindex.ts_query_cursor_set_byte_range"></div>nothrow @nogc void <code class="ddoc_psymbol">ts_query_cursor_set_byte_range</code>(TSQueryCursor*, uint, uint);
<br></div></dt>
<dd><div class="ddoc_summary">Set the range of bytes or (row, column) positions in which the query
 will be executed.</div></dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_query_cursor_did_exceed_match_limit"></span><div class="quickindex" id="quickindex.ts_query_cursor_did_exceed_match_limit"></div>nothrow @nogc bool <code class="ddoc_psymbol">ts_query_cursor_did_exceed_match_limit</code>(const(TSQueryCursor)*);
<br></div></dt>
<dd><div class="ddoc_summary">Manage the maximum number of in-progress matches allowed by this query
 cursor.
</div><div class="ddoc_description">Query cursors have an optional maximum capacity for storing lists of
 in-progress captures. If this capacity is exceeded, then the
 earliest-starting match will silently be dropped to make room for further
 matches. This maximum capacity is optional â€” by default, query cursors allow
 any number of pending matches, dynamically allocating new space for them as
 needed as the query is executed.</div>
</dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_query_cursor_exec"></span><div class="quickindex" id="quickindex.ts_query_cursor_exec"></div>nothrow @nogc void <code class="ddoc_psymbol">ts_query_cursor_exec</code>(TSQueryCursor*, const(TSQuery)*, TSNode);
<br></div></dt>
<dd><div class="ddoc_summary">Start running a given query on a given node.</div></dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_query_cursor_delete"></span><div class="quickindex" id="quickindex.ts_query_cursor_delete"></div>nothrow @nogc void <code class="ddoc_psymbol">ts_query_cursor_delete</code>(TSQueryCursor*);
<br></div></dt>
<dd><div class="ddoc_summary">Delete a query cursor, freeing all of the memory that it used.</div></dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_query_cursor_new"></span><div class="quickindex" id="quickindex.ts_query_cursor_new"></div>nothrow @nogc TSQueryCursor* <code class="ddoc_psymbol">ts_query_cursor_new</code>();
<br></div></dt>
<dd><div class="ddoc_summary">Create a new cursor for executing a given query.
</div><div class="ddoc_description">The cursor stores the state that is needed to iteratively search
 for matches. To use the query cursor, first call <code class="d_inlinecode donthyphenate notranslate">ts_query_cursor_exec</code>
 to start running a given query on a given syntax node. Then, there are
 two options for consuming the results of the query:
<ol><li>Repeatedly call <code class="d_inlinecode donthyphenate notranslate">ts_query_cursor_next_match</code> to iterate over all of the
    <em>matches</em> in the order that they were found. Each match contains the
    index of the pattern that matched, and an array of captures. Because
    multiple patterns can match the same set of nodes, one match may contain
    captures that appear <em>before</em> some of the captures from a previous match.</li>
<li>Repeatedly call <code class="d_inlinecode donthyphenate notranslate">ts_query_cursor_next_capture</code> to iterate over all of the
    individual <em>captures</em> in the order that they appear. This is useful if
    don't care about which pattern matched, and just want a single ordered
    sequence of captures.
</li>
</ol>
 If you don't care about consuming all of the results, you can stop calling
 <code class="d_inlinecode donthyphenate notranslate">ts_query_cursor_next_match</code> or <code class="d_inlinecode donthyphenate notranslate">ts_query_cursor_next_capture</code> at any point.
  You can then start executing another query on another node by calling
  <code class="d_inlinecode donthyphenate notranslate">ts_query_cursor_exec</code> again.</div>
</dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_query_disable_pattern"></span><div class="quickindex" id="quickindex.ts_query_disable_pattern"></div>nothrow @nogc void <code class="ddoc_psymbol">ts_query_disable_pattern</code>(TSQuery*, uint);
<br></div></dt>
<dd><div class="ddoc_summary">Disable a certain pattern within a query.
</div><div class="ddoc_description">This prevents the pattern from matching and removes most of the overhead
 associated with the pattern. Currently, there is no way to undo this.</div>
</dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_query_disable_capture"></span><div class="quickindex" id="quickindex.ts_query_disable_capture"></div>nothrow @nogc void <code class="ddoc_psymbol">ts_query_disable_capture</code>(TSQuery*, const(char)*, uint);
<br></div></dt>
<dd><div class="ddoc_summary">Disable a certain capture within a query.
</div><div class="ddoc_description">This prevents the capture from being returned in matches, and also avoids
 any resource usage associated with recording the capture. Currently, there
 is no way to undo this.</div>
</dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_query_capture_quantifier_for_id"></span><div class="quickindex" id="quickindex.ts_query_capture_quantifier_for_id"></div>nothrow @nogc TSQuantifier <code class="ddoc_psymbol">ts_query_capture_quantifier_for_id</code>(const(TSQuery)*, uint, uint);
<br></div></dt>
<dd><div class="ddoc_summary">Get the quantifier of the query's captures. Each capture is * associated
 with a numeric id based on the order that it appeared in the query's source.</div></dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_query_capture_name_for_id"></span><div class="quickindex" id="quickindex.ts_query_capture_name_for_id"></div>nothrow @nogc const(char)* <code class="ddoc_psymbol">ts_query_capture_name_for_id</code>(const(TSQuery)*, uint, uint*);
<br></div></dt>
<dd><div class="ddoc_summary">Get the name and length of one of the query's captures, or one of the
 query's string literals. Each capture and string is associated with a
 numeric id based on the order that it appeared in the query's source.</div></dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_query_predicates_for_pattern"></span><div class="quickindex" id="quickindex.ts_query_predicates_for_pattern"></div>nothrow @nogc const(TSQueryPredicateStep)* <code class="ddoc_psymbol">ts_query_predicates_for_pattern</code>(const(TSQuery)*, uint, uint*);
<br></div></dt>
<dd><div class="ddoc_summary">Get all of the predicates for the given pattern in the query.
</div><div class="ddoc_description">The predicates are represented as a single array of steps. There are three
 types of steps in this array, which correspond to the three legal values for
 the <code class="d_inlinecode donthyphenate notranslate">type</code> field:
<ul><li><code class="d_inlinecode donthyphenate notranslate">TSQueryPredicateStepTypeCapture</code> - Steps with this type represent names
    of captures. Their <code class="d_inlinecode donthyphenate notranslate">value_id</code> can be used with the
   <code class="d_inlinecode donthyphenate notranslate">ts_query_capture_name_for_id</code> function to obtain the name of the capture.</li>
<li><code class="d_inlinecode donthyphenate notranslate">TSQueryPredicateStepTypeString</code> - Steps with this type represent literal
    strings. Their <code class="d_inlinecode donthyphenate notranslate">value_id</code> can be used with the
    <code class="d_inlinecode donthyphenate notranslate">ts_query_string_value_for_id</code> function to obtain their string value.</li>
<li><code class="d_inlinecode donthyphenate notranslate">TSQueryPredicateStepTypeDone</code> - Steps with this type are <em>sentinels</em>
    that represent the end of an individual predicate. If a pattern has two
    predicates, then there will be two steps with this <code class="d_inlinecode donthyphenate notranslate">type</code> in the array.</li>
</ul></div>
</dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_query_start_byte_for_pattern"></span><div class="quickindex" id="quickindex.ts_query_start_byte_for_pattern"></div>nothrow @nogc uint <code class="ddoc_psymbol">ts_query_start_byte_for_pattern</code>(const(TSQuery)*, uint);
<br></div></dt>
<dd><div class="ddoc_summary">Get the byte offset where the given pattern starts in the query's source.
</div><div class="ddoc_description">This can be useful when combining queries by concatenating their source
 code strings.</div>
</dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_query_pattern_count"></span><div class="quickindex" id="quickindex.ts_query_pattern_count"></div>nothrow @nogc uint <code class="ddoc_psymbol">ts_query_pattern_count</code>(const(TSQuery)*);
<br></div></dt>
<dd><div class="ddoc_summary">Get the number of patterns, captures, or string literals in the query.</div></dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_query_delete"></span><div class="quickindex" id="quickindex.ts_query_delete"></div>nothrow @nogc void <code class="ddoc_psymbol">ts_query_delete</code>(TSQuery*);
<br></div></dt>
<dd><div class="ddoc_summary">Delete a query, freeing all of the memory that it used.</div></dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_query_new"></span><div class="quickindex" id="quickindex.ts_query_new"></div>nothrow @nogc TSQuery* <code class="ddoc_psymbol">ts_query_new</code>(const(TSLanguage)*, const(char)*, uint, uint*, TSQueryError*);
<br></div></dt>
<dd><div class="ddoc_summary">Create a new query from a string containing one or more S-expression
 patterns. The query is associated with a particular language, and can
 only be run on syntax nodes parsed with that language.
</div><div class="ddoc_description">If all of the given patterns are valid, this returns a <code class="d_inlinecode donthyphenate notranslate">TSQuery</code>.
 If a pattern is invalid, this returns <code class="d_inlinecode donthyphenate notranslate">NULL</code>, and provides two pieces
 of information about the problem:
<ol><li>The byte offset of the error is written to the <code class="d_inlinecode donthyphenate notranslate">error_offset</code> parameter.</li>
<li>The type of error is written to the <code class="d_inlinecode donthyphenate notranslate">error_type</code> parameter.</li>
</ol></div>
</dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_tree_cursor_goto_first_child_for_byte"></span><div class="quickindex" id="quickindex.ts_tree_cursor_goto_first_child_for_byte"></div>nothrow @nogc long <code class="ddoc_psymbol">ts_tree_cursor_goto_first_child_for_byte</code>(TSTreeCursor*, uint);
<br></div></dt>
<dd><div class="ddoc_summary">Move the cursor to the first child of its current node that extends beyond
 the given byte offset or point.
</div><div class="ddoc_description">This returns the index of the child node if one was found, and returns -1
 if no such child was found.</div>
</dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_tree_cursor_goto_first_child"></span><div class="quickindex" id="quickindex.ts_tree_cursor_goto_first_child"></div>nothrow @nogc bool <code class="ddoc_psymbol">ts_tree_cursor_goto_first_child</code>(TSTreeCursor*);
<br></div></dt>
<dd><div class="ddoc_summary">Move the cursor to the first child of its current node.
</div><div class="ddoc_description">This returns <code class="d_inlinecode donthyphenate notranslate">true</code> if the cursor successfully moved, and returns <code class="d_inlinecode donthyphenate notranslate">false</code>
 if there were no children.</div>
</dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_tree_cursor_goto_next_sibling"></span><div class="quickindex" id="quickindex.ts_tree_cursor_goto_next_sibling"></div>nothrow @nogc bool <code class="ddoc_psymbol">ts_tree_cursor_goto_next_sibling</code>(TSTreeCursor*);
<br></div></dt>
<dd><div class="ddoc_summary">Move the cursor to the next sibling of its current node.
</div><div class="ddoc_description">This returns <code class="d_inlinecode donthyphenate notranslate">true</code> if the cursor successfully moved, and returns <code class="d_inlinecode donthyphenate notranslate">false</code>
 if there was no next sibling node.</div>
</dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_tree_cursor_goto_parent"></span><div class="quickindex" id="quickindex.ts_tree_cursor_goto_parent"></div>nothrow @nogc bool <code class="ddoc_psymbol">ts_tree_cursor_goto_parent</code>(TSTreeCursor*);
<br></div></dt>
<dd><div class="ddoc_summary">Move the cursor to the parent of its current node.
</div><div class="ddoc_description">This returns <code class="d_inlinecode donthyphenate notranslate">true</code> if the cursor successfully moved, and returns <code class="d_inlinecode donthyphenate notranslate">false</code>
 if there was no parent node (the cursor was already on the root node).</div>
</dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_tree_cursor_current_field_id"></span><div class="quickindex" id="quickindex.ts_tree_cursor_current_field_id"></div>nothrow @nogc ushort <code class="ddoc_psymbol">ts_tree_cursor_current_field_id</code>(const(TSTreeCursor)*);
<br></div></dt>
<dd><div class="ddoc_summary">Get the field id of the tree cursor's current node.
</div><div class="ddoc_description">This returns zero if the current node doesn't have a field.
 See also <code class="d_inlinecode donthyphenate notranslate">ts_node_child_by_field_id</code>, <code class="d_inlinecode donthyphenate notranslate">ts_language_field_id_for_name</code>.</div>
</dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_tree_cursor_current_field_name"></span><div class="quickindex" id="quickindex.ts_tree_cursor_current_field_name"></div>nothrow @nogc const(char)* <code class="ddoc_psymbol">ts_tree_cursor_current_field_name</code>(const(TSTreeCursor)*);
<br></div></dt>
<dd><div class="ddoc_summary">Get the field name of the tree cursor's current node.
</div><div class="ddoc_description">This returns <code class="d_inlinecode donthyphenate notranslate">NULL</code> if the current node doesn't have a field.
 See also <code class="d_inlinecode donthyphenate notranslate">ts_node_child_by_field_name</code>.</div>
</dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_tree_cursor_current_node"></span><div class="quickindex" id="quickindex.ts_tree_cursor_current_node"></div>nothrow @nogc TSNode <code class="ddoc_psymbol">ts_tree_cursor_current_node</code>(const(TSTreeCursor)*);
<br></div></dt>
<dd><div class="ddoc_summary">Get the tree cursor's current node.</div></dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_tree_cursor_reset"></span><div class="quickindex" id="quickindex.ts_tree_cursor_reset"></div>nothrow @nogc void <code class="ddoc_psymbol">ts_tree_cursor_reset</code>(TSTreeCursor*, TSNode);
<br></div></dt>
<dd><div class="ddoc_summary">Re-initialize a tree cursor to start at a different node.</div></dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_tree_cursor_delete"></span><div class="quickindex" id="quickindex.ts_tree_cursor_delete"></div>nothrow @nogc void <code class="ddoc_psymbol">ts_tree_cursor_delete</code>(TSTreeCursor*);
<br></div></dt>
<dd><div class="ddoc_summary">Delete a tree cursor, freeing all of the memory that it used.</div></dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_tree_cursor_new"></span><div class="quickindex" id="quickindex.ts_tree_cursor_new"></div>nothrow @nogc TSTreeCursor <code class="ddoc_psymbol">ts_tree_cursor_new</code>(TSNode);
<br></div></dt>
<dd><div class="ddoc_summary">Create a new tree cursor starting from the given node.
</div><div class="ddoc_description">A tree cursor allows you to walk a syntax tree more efficiently than is
 possible using the <code class="d_inlinecode donthyphenate notranslate">TSNode</code> functions. It is a mutable object that is always
 on a certain syntax node, and can be moved imperatively to different nodes.</div>
</dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_node_eq"></span><div class="quickindex" id="quickindex.ts_node_eq"></div>nothrow @nogc bool <code class="ddoc_psymbol">ts_node_eq</code>(TSNode, TSNode);
<br></div></dt>
<dd><div class="ddoc_summary">Check if two nodes are identical.</div></dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_node_edit"></span><div class="quickindex" id="quickindex.ts_node_edit"></div>nothrow @nogc void <code class="ddoc_psymbol">ts_node_edit</code>(TSNode*, const(TSInputEdit)*);
<br></div></dt>
<dd><div class="ddoc_summary">Edit the node to keep it in-sync with source code that has been edited.
</div><div class="ddoc_description">This function is only rarely needed. When you edit a syntax tree with the
 <code class="d_inlinecode donthyphenate notranslate">ts_tree_edit</code> function, all of the nodes that you retrieve from the tree
 afterward will already reflect the edit. You only need to use <code class="d_inlinecode donthyphenate notranslate"><code class="ddoc_psymbol">ts_node_edit</code></code>
 when you have a <code class="d_inlinecode donthyphenate notranslate">TSNode</code> instance that you want to keep and continue to use
 after an edit.</div>
</dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_node_named_descendant_for_byte_range"></span><div class="quickindex" id="quickindex.ts_node_named_descendant_for_byte_range"></div>nothrow @nogc TSNode <code class="ddoc_psymbol">ts_node_named_descendant_for_byte_range</code>(TSNode, uint, uint);
<br></div></dt>
<dd><div class="ddoc_summary">Get the smallest named node within this node that spans the given range of
 bytes or (row, column) positions.</div></dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_node_descendant_for_byte_range"></span><div class="quickindex" id="quickindex.ts_node_descendant_for_byte_range"></div>nothrow @nogc TSNode <code class="ddoc_psymbol">ts_node_descendant_for_byte_range</code>(TSNode, uint, uint);
<br></div></dt>
<dd><div class="ddoc_summary">Get the smallest node within this node that spans the given range of bytes
 or (row, column) positions.</div></dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_node_first_named_child_for_byte"></span><div class="quickindex" id="quickindex.ts_node_first_named_child_for_byte"></div>nothrow @nogc TSNode <code class="ddoc_psymbol">ts_node_first_named_child_for_byte</code>(TSNode, uint);
<br></div></dt>
<dd><div class="ddoc_summary">Get the node's first named child that extends beyond the given byte offset.</div></dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_node_first_child_for_byte"></span><div class="quickindex" id="quickindex.ts_node_first_child_for_byte"></div>nothrow @nogc TSNode <code class="ddoc_psymbol">ts_node_first_child_for_byte</code>(TSNode, uint);
<br></div></dt>
<dd><div class="ddoc_summary">Get the node's first child that extends beyond the given byte offset.</div></dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_node_next_named_sibling"></span><div class="quickindex" id="quickindex.ts_node_next_named_sibling"></div>nothrow @nogc TSNode <code class="ddoc_psymbol">ts_node_next_named_sibling</code>(TSNode);
<br></div></dt>
<dd><div class="ddoc_summary">Get the node's next / previous <em>named</em> sibling.</div></dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_node_next_sibling"></span><div class="quickindex" id="quickindex.ts_node_next_sibling"></div>nothrow @nogc TSNode <code class="ddoc_psymbol">ts_node_next_sibling</code>(TSNode);
<br></div></dt>
<dd><div class="ddoc_summary">Get the node's next / previous sibling.</div></dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_node_child_by_field_id"></span><div class="quickindex" id="quickindex.ts_node_child_by_field_id"></div>nothrow @nogc TSNode <code class="ddoc_psymbol">ts_node_child_by_field_id</code>(TSNode, ushort);
<br></div></dt>
<dd><div class="ddoc_summary">Get the node's child with the given numerical field id.
</div><div class="ddoc_description">You can convert a field name to an id using the
 <code class="d_inlinecode donthyphenate notranslate">ts_language_field_id_for_name</code> function.</div>
</dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_node_child_by_field_name"></span><div class="quickindex" id="quickindex.ts_node_child_by_field_name"></div>nothrow @nogc TSNode <code class="ddoc_psymbol">ts_node_child_by_field_name</code>(TSNode, const(char)*, uint);
<br></div></dt>
<dd><div class="ddoc_summary">Get the node's child with the given field name.</div></dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_node_named_child_count"></span><div class="quickindex" id="quickindex.ts_node_named_child_count"></div>nothrow @nogc uint <code class="ddoc_psymbol">ts_node_named_child_count</code>(TSNode);
<br></div></dt>
<dd><div class="ddoc_summary">Get the node's number of <em>named</em> children.
</div><div class="ddoc_description">See also <code class="d_inlinecode donthyphenate notranslate">ts_node_is_named</code>.</div>
</dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_node_named_child"></span><div class="quickindex" id="quickindex.ts_node_named_child"></div>nothrow @nogc TSNode <code class="ddoc_psymbol">ts_node_named_child</code>(TSNode, uint);
<br></div></dt>
<dd><div class="ddoc_summary">Get the node's <em>named</em> child at the given index.
</div><div class="ddoc_description">See also <code class="d_inlinecode donthyphenate notranslate">ts_node_is_named</code>.</div>
</dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_node_child_count"></span><div class="quickindex" id="quickindex.ts_node_child_count"></div>nothrow @nogc uint <code class="ddoc_psymbol">ts_node_child_count</code>(TSNode);
<br></div></dt>
<dd><div class="ddoc_summary">Get the node's number of children.</div></dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_node_field_name_for_child"></span><div class="quickindex" id="quickindex.ts_node_field_name_for_child"></div>nothrow @nogc const(char)* <code class="ddoc_psymbol">ts_node_field_name_for_child</code>(TSNode, uint);
<br></div></dt>
<dd><div class="ddoc_summary">Get the field name for node's child at the given index, where zero represents
 the first child. Returns NULL, if no field is found.</div></dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_node_child"></span><div class="quickindex" id="quickindex.ts_node_child"></div>nothrow @nogc TSNode <code class="ddoc_psymbol">ts_node_child</code>(TSNode, uint);
<br></div></dt>
<dd><div class="ddoc_summary">Get the node's child at the given index, where zero represents the first
 child.</div></dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_node_parent"></span><div class="quickindex" id="quickindex.ts_node_parent"></div>nothrow @nogc TSNode <code class="ddoc_psymbol">ts_node_parent</code>(TSNode);
<br></div></dt>
<dd><div class="ddoc_summary">Get the node's immediate parent.</div></dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_node_has_error"></span><div class="quickindex" id="quickindex.ts_node_has_error"></div>nothrow @nogc bool <code class="ddoc_psymbol">ts_node_has_error</code>(TSNode);
<br></div></dt>
<dd><div class="ddoc_summary">Check if the node is a syntax error or contains any syntax errors.</div></dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_node_has_changes"></span><div class="quickindex" id="quickindex.ts_node_has_changes"></div>nothrow @nogc bool <code class="ddoc_psymbol">ts_node_has_changes</code>(TSNode);
<br></div></dt>
<dd><div class="ddoc_summary">Check if a syntax node has been edited.</div></dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_node_is_extra"></span><div class="quickindex" id="quickindex.ts_node_is_extra"></div>nothrow @nogc bool <code class="ddoc_psymbol">ts_node_is_extra</code>(TSNode);
<br></div></dt>
<dd><div class="ddoc_summary">Check if the node is <em>extra</em>. Extra nodes represent things like comments,
 which are not required the grammar, but can appear anywhere.</div></dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_node_is_missing"></span><div class="quickindex" id="quickindex.ts_node_is_missing"></div>nothrow @nogc bool <code class="ddoc_psymbol">ts_node_is_missing</code>(TSNode);
<br></div></dt>
<dd><div class="ddoc_summary">Check if the node is <em>missing</em>. Missing nodes are inserted by the parser in
 order to recover from certain kinds of syntax errors.</div></dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_node_is_named"></span><div class="quickindex" id="quickindex.ts_node_is_named"></div>nothrow @nogc bool <code class="ddoc_psymbol">ts_node_is_named</code>(TSNode);
<br></div></dt>
<dd><div class="ddoc_summary">Check if the node is <em>named</em>. Named nodes correspond to named rules in the
 grammar, whereas <em>anonymous</em> nodes correspond to string literals in the
 grammar.</div></dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_node_is_null"></span><div class="quickindex" id="quickindex.ts_node_is_null"></div>nothrow @nogc bool <code class="ddoc_psymbol">ts_node_is_null</code>(TSNode);
<br></div></dt>
<dd><div class="ddoc_summary">Check if the node is <code class="ddoc_keyword">null</code>. Functions like <code class="d_inlinecode donthyphenate notranslate">ts_node_child</code> and
 <code class="d_inlinecode donthyphenate notranslate">ts_node_next_sibling</code> will return a <code class="ddoc_keyword">null</code> node to indicate that no such node
 was found.</div></dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_node_string"></span><div class="quickindex" id="quickindex.ts_node_string"></div>nothrow @nogc char* <code class="ddoc_psymbol">ts_node_string</code>(TSNode);
<br></div></dt>
<dd><div class="ddoc_summary">Get an S-expression representing the node as a string.
</div><div class="ddoc_description">This string is allocated with <code class="d_inlinecode donthyphenate notranslate">malloc</code> and the caller is responsible for
 freeing it using <code class="d_inlinecode donthyphenate notranslate">free</code>.</div>
</dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_node_end_point"></span><div class="quickindex" id="quickindex.ts_node_end_point"></div>nothrow @nogc TSPoint <code class="ddoc_psymbol">ts_node_end_point</code>(TSNode);
<br></div></dt>
<dd><div class="ddoc_summary">Get the node's end position in terms of rows and columns.</div></dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_node_end_byte"></span><div class="quickindex" id="quickindex.ts_node_end_byte"></div>nothrow @nogc uint <code class="ddoc_psymbol">ts_node_end_byte</code>(TSNode);
<br></div></dt>
<dd><div class="ddoc_summary">Get the node's end byte.</div></dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_node_start_point"></span><div class="quickindex" id="quickindex.ts_node_start_point"></div>nothrow @nogc TSPoint <code class="ddoc_psymbol">ts_node_start_point</code>(TSNode);
<br></div></dt>
<dd><div class="ddoc_summary">Get the node's start position in terms of rows and columns.</div></dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_node_start_byte"></span><div class="quickindex" id="quickindex.ts_node_start_byte"></div>nothrow @nogc uint <code class="ddoc_psymbol">ts_node_start_byte</code>(TSNode);
<br></div></dt>
<dd><div class="ddoc_summary">Get the node's start byte.</div></dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_node_symbol"></span><div class="quickindex" id="quickindex.ts_node_symbol"></div>nothrow @nogc ushort <code class="ddoc_psymbol">ts_node_symbol</code>(TSNode);
<br></div></dt>
<dd><div class="ddoc_summary">Get the node's type as a numerical id.</div></dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_node_type"></span><div class="quickindex" id="quickindex.ts_node_type"></div>nothrow @nogc const(char)* <code class="ddoc_psymbol">ts_node_type</code>(TSNode);
<br></div></dt>
<dd><div class="ddoc_summary">Get the node's type as a <code class="ddoc_keyword">null</code>-terminated string.</div></dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_tree_print_dot_graph"></span><div class="quickindex" id="quickindex.ts_tree_print_dot_graph"></div>nothrow @nogc void <code class="ddoc_psymbol">ts_tree_print_dot_graph</code>(const(TSTree)*, _iobuf*);
<br></div></dt>
<dd><div class="ddoc_summary">Write a DOT graph describing the syntax tree to the given file.</div></dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_tree_get_changed_ranges"></span><div class="quickindex" id="quickindex.ts_tree_get_changed_ranges"></div>nothrow @nogc TSRange* <code class="ddoc_psymbol">ts_tree_get_changed_ranges</code>(const(TSTree)*, const(TSTree)*, uint*);
<br></div></dt>
<dd><div class="ddoc_summary">Compare an old edited syntax tree to a new syntax tree representing the same
 document, returning an array of ranges whose syntactic structure has changed.
</div><div class="ddoc_description">For this to work correctly, the old syntax tree must have been edited such
 that its ranges match up to the new tree. Generally, you'll want to call
 this function right after calling one of the <code class="d_inlinecode donthyphenate notranslate">ts_parser_parse</code> functions.
 You need to pass the old tree that was passed to parse, as well as the new
 tree that was returned from that function.
<div class="ddoc_blankline"></div>

 The returned array is allocated using <code class="d_inlinecode donthyphenate notranslate">malloc</code> and the caller is responsible
 for freeing it using <code class="d_inlinecode donthyphenate notranslate">free</code>. The length of the array will be written to the
 given <code class="d_inlinecode donthyphenate notranslate">length</code> pointer.</div>
</dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_tree_edit"></span><div class="quickindex" id="quickindex.ts_tree_edit"></div>nothrow @nogc void <code class="ddoc_psymbol">ts_tree_edit</code>(TSTree*, const(TSInputEdit)*);
<br></div></dt>
<dd><div class="ddoc_summary">Edit the syntax tree to keep it in sync with source code that has been
 edited.
</div><div class="ddoc_description">You must describe the edit both in terms of byte offsets and in terms of
 (row, column) coordinates.</div>
</dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_tree_language"></span><div class="quickindex" id="quickindex.ts_tree_language"></div>nothrow @nogc const(TSLanguage)* <code class="ddoc_psymbol">ts_tree_language</code>(const(TSTree)*);
<br></div></dt>
<dd><div class="ddoc_summary">Get the language that was used to parse the syntax tree.</div></dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_tree_root_node"></span><div class="quickindex" id="quickindex.ts_tree_root_node"></div>nothrow @nogc TSNode <code class="ddoc_psymbol">ts_tree_root_node</code>(const(TSTree)*);
<br></div></dt>
<dd><div class="ddoc_summary">Get the root node of the syntax tree.</div></dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_tree_delete"></span><div class="quickindex" id="quickindex.ts_tree_delete"></div>nothrow @nogc void <code class="ddoc_psymbol">ts_tree_delete</code>(TSTree*);
<br></div></dt>
<dd><div class="ddoc_summary">Delete the syntax tree, freeing all of the memory that it used.</div></dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_tree_copy"></span><div class="quickindex" id="quickindex.ts_tree_copy"></div>nothrow @nogc TSTree* <code class="ddoc_psymbol">ts_tree_copy</code>(const(TSTree)*);
<br></div></dt>
<dd><div class="ddoc_summary">Create a shallow copy of the syntax tree. This is very fast.
</div><div class="ddoc_description">You need to copy a syntax tree in order to use it on more than one thread at
 a time, as syntax trees are not thread safe.</div>
</dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_parser_print_dot_graphs"></span><div class="quickindex" id="quickindex.ts_parser_print_dot_graphs"></div>nothrow @nogc void <code class="ddoc_psymbol">ts_parser_print_dot_graphs</code>(TSParser*, int);
<br></div></dt>
<dd><div class="ddoc_summary">Set the file descriptor to which the parser should write debugging graphs
 during parsing. The graphs are formatted in the DOT language. You may want
 to pipe these graphs directly to a <code class="d_inlinecode donthyphenate notranslate">dot(1)</code> process in order to generate
 SVG output. You can turn off this logging by passing a negative number.</div></dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_parser_logger"></span><div class="quickindex" id="quickindex.ts_parser_logger"></div>nothrow @nogc TSLogger <code class="ddoc_psymbol">ts_parser_logger</code>(const(TSParser)*);
<br></div></dt>
<dd><div class="ddoc_summary">Get the parser's current logger.</div></dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_parser_set_logger"></span><div class="quickindex" id="quickindex.ts_parser_set_logger"></div>nothrow @nogc void <code class="ddoc_psymbol">ts_parser_set_logger</code>(TSParser*, TSLogger);
<br></div></dt>
<dd><div class="ddoc_summary">Set the logger that a parser should use during parsing.
</div><div class="ddoc_description">The parser does not take ownership over the logger payload. If a logger was
 previously assigned, the caller is responsible for releasing any memory
 owned by the previous logger.</div>
</dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_parser_cancellation_flag"></span><div class="quickindex" id="quickindex.ts_parser_cancellation_flag"></div>nothrow @nogc const(ulong)* <code class="ddoc_psymbol">ts_parser_cancellation_flag</code>(const(TSParser)*);
<br></div></dt>
<dd><div class="ddoc_summary">Get the parser's current cancellation flag pointer.</div></dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_parser_set_cancellation_flag"></span><div class="quickindex" id="quickindex.ts_parser_set_cancellation_flag"></div>nothrow @nogc void <code class="ddoc_psymbol">ts_parser_set_cancellation_flag</code>(TSParser*, const(ulong)*);
<br></div></dt>
<dd><div class="ddoc_summary">Set the parser's current cancellation flag pointer.
</div><div class="ddoc_description">If a non-<code class="ddoc_keyword">null</code> pointer is assigned, then the parser will periodically read
 from this pointer during parsing. If it reads a non-zero value, it will
 halt early, returning NULL. See <code class="d_inlinecode donthyphenate notranslate">ts_parser_parse</code> for more information.</div>
</dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_parser_timeout_micros"></span><div class="quickindex" id="quickindex.ts_parser_timeout_micros"></div>nothrow @nogc ulong <code class="ddoc_psymbol">ts_parser_timeout_micros</code>(const(TSParser)*);
<br></div></dt>
<dd><div class="ddoc_summary">Get the duration in microseconds that parsing is allowed to take.</div></dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_parser_set_timeout_micros"></span><div class="quickindex" id="quickindex.ts_parser_set_timeout_micros"></div>nothrow @nogc void <code class="ddoc_psymbol">ts_parser_set_timeout_micros</code>(TSParser*, ulong);
<br></div></dt>
<dd><div class="ddoc_summary">Set the maximum duration in microseconds that parsing should be allowed to
 take before halting.
</div><div class="ddoc_description">If parsing takes longer than this, it will halt early, returning NULL.
 See <code class="d_inlinecode donthyphenate notranslate">ts_parser_parse</code> for more information.</div>
</dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_parser_reset"></span><div class="quickindex" id="quickindex.ts_parser_reset"></div>nothrow @nogc void <code class="ddoc_psymbol">ts_parser_reset</code>(TSParser*);
<br></div></dt>
<dd><div class="ddoc_summary">Instruct the parser to start the next parse from the beginning.
</div><div class="ddoc_description">If the parser previously failed because of a timeout or a cancellation, then
 by default, it will resume where it left off on the next call to
 <code class="d_inlinecode donthyphenate notranslate">ts_parser_parse</code> or other parsing functions. If you don't want to resume,
 and instead intend to use this parser to parse some other document, you must
 call <code class="d_inlinecode donthyphenate notranslate"><code class="ddoc_psymbol">ts_parser_reset</code></code> first.</div>
</dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_parser_parse_string_encoding"></span><div class="quickindex" id="quickindex.ts_parser_parse_string_encoding"></div>nothrow @nogc TSTree* <code class="ddoc_psymbol">ts_parser_parse_string_encoding</code>(TSParser*, const(TSTree)*, const(char)*, uint, TSInputEncoding);
<br></div></dt>
<dd><div class="ddoc_summary">Use the parser to parse some source code stored in one contiguous buffer with
 a given encoding. The first four parameters work the same as in the
 <code class="d_inlinecode donthyphenate notranslate">ts_parser_parse_string</code> method above. The final parameter indicates whether
 the text is encoded as UTF8 or UTF16.</div></dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_parser_parse_string"></span><div class="quickindex" id="quickindex.ts_parser_parse_string"></div>nothrow @nogc TSTree* <code class="ddoc_psymbol">ts_parser_parse_string</code>(TSParser*, const(TSTree)*, const(char)*, uint);
<br></div></dt>
<dd><div class="ddoc_summary">Use the parser to parse some source code stored in one contiguous buffer.
 The first two parameters are the same as in the <code class="d_inlinecode donthyphenate notranslate">ts_parser_parse</code> function
 above. The second two parameters indicate the location of the buffer and its
 length in bytes.</div></dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_parser_parse"></span><div class="quickindex" id="quickindex.ts_parser_parse"></div>nothrow @nogc TSTree* <code class="ddoc_psymbol">ts_parser_parse</code>(TSParser*, const(TSTree)*, TSInput);
<br></div></dt>
<dd><div class="ddoc_summary">Use the parser to parse some source code and create a syntax tree.
</div><div class="ddoc_description">If you are parsing this document for the first time, pass <code class="d_inlinecode donthyphenate notranslate">NULL</code> for the
 <code class="d_inlinecode donthyphenate notranslate">old_tree</code> parameter. Otherwise, if you have already parsed an earlier
 version of this document and the document has since been edited, pass the
 previous syntax tree so that the unchanged parts of it can be reused.
 This will save time and memory. For this to work correctly, you must have
 already edited the old syntax tree using the <code class="d_inlinecode donthyphenate notranslate">ts_tree_edit</code> function in a
 way that exactly matches the source code changes.
<div class="ddoc_blankline"></div>

 The <code class="d_inlinecode donthyphenate notranslate">TSInput</code> parameter lets you specify how to read the text. It has the
 following three fields:
<ol><li><code class="d_inlinecode donthyphenate notranslate">read</code>: A function to retrieve a chunk of text at a given byte offset
    and (row, column) position. The function should return a pointer to the
    text and write its length to the <code class="d_inlinecode donthyphenate notranslate">bytes_read</code> pointer. The parser does
    not take ownership of this buffer; it just borrows it until it has
    finished reading it. The function should write a zero value to the
    <code class="d_inlinecode donthyphenate notranslate">bytes_read</code> pointer to indicate the end of the document.</li>
<li><code class="d_inlinecode donthyphenate notranslate">payload</code>: An arbitrary pointer that will be passed to each invocation
    of the <code class="d_inlinecode donthyphenate notranslate">read</code> function.</li>
<li><code class="d_inlinecode donthyphenate notranslate">encoding</code>: An indication of how the text is encoded. Either
    <code class="d_inlinecode donthyphenate notranslate">TSInputEncodingUTF8</code> or <code class="d_inlinecode donthyphenate notranslate">TSInputEncodingUTF16</code>.
</li>
</ol>
 This function returns a syntax tree on success, and <code class="d_inlinecode donthyphenate notranslate">NULL</code> on failure. There
 are three possible reasons for failure:
<ol><li>The parser does not have a language assigned. Check for this using the
      <code class="d_inlinecode donthyphenate notranslate">ts_parser_language</code> function.</li>
<li>Parsing was cancelled due to a timeout that was set by an earlier call to
    the <code class="d_inlinecode donthyphenate notranslate">ts_parser_set_timeout_micros</code> function. You can resume parsing from
    where the parser left out by calling <code class="d_inlinecode donthyphenate notranslate"><code class="ddoc_psymbol">ts_parser_parse</code></code> again with the
    same arguments. Or you can start parsing from scratch by first calling
    <code class="d_inlinecode donthyphenate notranslate">ts_parser_reset</code>.</li>
<li>Parsing was cancelled using a cancellation flag that was set by an
    earlier call to <code class="d_inlinecode donthyphenate notranslate">ts_parser_set_cancellation_flag</code>. You can resume parsing
    from where the parser left out by calling <code class="d_inlinecode donthyphenate notranslate"><code class="ddoc_psymbol">ts_parser_parse</code></code> again with
    the same arguments.</li>
</ol></div>
</dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_parser_included_ranges"></span><div class="quickindex" id="quickindex.ts_parser_included_ranges"></div>nothrow @nogc const(TSRange)* <code class="ddoc_psymbol">ts_parser_included_ranges</code>(const(TSParser)*, uint*);
<br></div></dt>
<dd><div class="ddoc_summary">Get the ranges of text that the parser will include when parsing.
</div><div class="ddoc_description">The returned pointer is owned by the parser. The caller should not free it
 or write to it. The length of the array will be written to the given
 <code class="d_inlinecode donthyphenate notranslate">length</code> pointer.</div>
</dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_parser_set_included_ranges"></span><div class="quickindex" id="quickindex.ts_parser_set_included_ranges"></div>nothrow @nogc bool <code class="ddoc_psymbol">ts_parser_set_included_ranges</code>(TSParser*, const(TSRange)*, uint);
<br></div></dt>
<dd><div class="ddoc_summary">Set the ranges of text that the parser should include when parsing.
</div><div class="ddoc_description">By default, the parser will always include entire documents. This function
 allows you to parse only a <em>portion</em> of a document but still return a syntax
 tree whose ranges match up with the document as a whole. You can also pass
 multiple disjoint ranges.
<div class="ddoc_blankline"></div>

 The second and third parameters specify the location and length of an array
 of ranges. The parser does <em>not</em> take ownership of these ranges; it copies
 the data, so it doesn't matter how these ranges are allocated.
<div class="ddoc_blankline"></div>

 If <code class="d_inlinecode donthyphenate notranslate">length</code> is zero, then the entire document will be parsed. Otherwise,
 the given ranges must be ordered from earliest to latest in the document,
 and they must not overlap. That is, the following must hold for all
 <code class="d_inlinecode donthyphenate notranslate">i</code> &lt; <code class="d_inlinecode donthyphenate notranslate">length - 1</code>: ranges[i].end_byte &lt;= ranges[i + 1].start_byte
<div class="ddoc_blankline"></div>

 If this requirement is not satisfied, the operation will fail, the ranges
 will not be assigned, and this function will return <code class="d_inlinecode donthyphenate notranslate">false</code>. On success,
 this function returns <code class="d_inlinecode donthyphenate notranslate">true</code></div>
</dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_parser_language"></span><div class="quickindex" id="quickindex.ts_parser_language"></div>nothrow @nogc const(TSLanguage)* <code class="ddoc_psymbol">ts_parser_language</code>(const(TSParser)*);
<br></div></dt>
<dd><div class="ddoc_summary">Get the parser's current language.</div></dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_parser_set_language"></span><div class="quickindex" id="quickindex.ts_parser_set_language"></div>nothrow @nogc bool <code class="ddoc_psymbol">ts_parser_set_language</code>(TSParser*, const(TSLanguage)*);
<br></div></dt>
<dd><div class="ddoc_summary">Set the language that the parser should use for parsing.
</div><div class="ddoc_description">Returns a boolean indicating whether or not the language was successfully
 assigned. True means assignment succeeded. False means there was a version
 mismatch: the language was generated with an incompatible version of the
 Tree-sitter CLI. Check the language's version using <code class="d_inlinecode donthyphenate notranslate">ts_language_version</code>
 and compare it to this library's <code class="d_inlinecode donthyphenate notranslate">TREE_SITTER_LANGUAGE_VERSION</code> and
 <code class="d_inlinecode donthyphenate notranslate">TREE_SITTER_MIN_COMPATIBLE_LANGUAGE_VERSION</code> constants.</div>
</dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_parser_delete"></span><div class="quickindex" id="quickindex.ts_parser_delete"></div>nothrow @nogc void <code class="ddoc_psymbol">ts_parser_delete</code>(TSParser*);
<br></div></dt>
<dd><div class="ddoc_summary">Delete the parser, freeing all of the memory that it used.</div></dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".ts_parser_new"></span><div class="quickindex" id="quickindex.ts_parser_new"></div>nothrow @nogc TSParser* <code class="ddoc_psymbol">ts_parser_new</code>();
<br></div></dt>
<dd><div class="ddoc_summary">Create a new parser.</div></dd>
<dt class="ddoc_decl"><div ><span class="def-anchor" id=".TSSymbol"></span><div class="quickindex" id="quickindex.TSSymbol"></div>alias <code class="ddoc_psymbol">TSSymbol</code> = ushort;
<br></div></dt>
<dd>
</dd>
</div></dl>

                
            </div>
        </div>
        
        <script type="text/javascript">jQuery(document).ready(listanchors);</script>
        
        
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">
     </body>
</html>